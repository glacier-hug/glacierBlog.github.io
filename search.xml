<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[11.IP命令]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F11%2F11-IP%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[IP命令Linux的ip命令和ifconfig类似，但前者功能更强大，并旨在取代后者。使用ip命令，只需一个命令，你就能很轻松地执行一些网络管理任务。ifconfig是net-tools中已被废弃使用的一个命令，许多年前就已经没有维护了。iproute2套件里提供了许多增强功能的命令，ip命令即是其中之一。 单一命令ip [ OPTIONS ] OBJECT { COMMAND | help } Option是一些修改ip行为或者改变其输出的选项，所有的选项都是以-字符开头，分为长、短两种形式: OPTIONS 全称 含义 -c color 加颜色显示 -t timestamp 在motier中加入时间 -V Version 打印ip的版本并退出 -h human 人类可读输出 -s statistics 输出统计信息 -d detail 输出更多的细节信息 -l loo 指定”IP地址刷新”逻辑将尝试的最大循环数，默认为10 -f family 指定要使用的协议族，协议可以是一个inet)(-4)，inet6(-6)、bridge(-B), ipx(-I), dnet(-D) or link(-0) -o oneline 单行输出，用”\”字符替换换行符 -n netns 交换机的IP到指定的网络空间netns -r resolve 使用系统名称解析来打印DNS名称而不是主机地址 -a all 对所有对象执行指定的命令，这取决于命令是否支持这个选项 -rc recive buf 设置Netlink套接字接收缓冲区的大小设置，默认为1MB OBJECT 全称 含义 link linu 网络设备 address Adress ip或ipv6地址及对应的设备 neighbor neighbor ARP或者NDISC缓冲区条目 route Route 路由表目录 rule Rule 基于策略的路由配置 maddress Multiple Address 多播地址 mroute Multiple Route 多播路由 mrule Multiple Rule 组播路由策略数据库中的规则 tunnel Tunnel IP上的通道 monitor monitor 监视网络状态 COMMAND 全称 含义 show Show 显示 list List 显示 add Add 增加规则 delete Delete 删除规则 help Help 查看对应object操作的帮助 批处理ip [ -force ] -batch filename-force：不要终止批处理模式中的错误-b：-batch filenam，从提供的文件或标准输入中读取命令并调用它们，第一次失败将导致IP终止 ss命令SS(Socket Status)查看套接字状态的命令，等同于net-tools中的netstat命令，但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。 天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。 语法与netstat类似 Option 全称 含义 n numberic 不解析服务名称，以数字方式显示 t tcp 只显示tcp协议的套接字 u udp 只显示udp协议的套接字 l listen 显示监听状态的套接字 p process 显示进程信息 a all 显示所有状态的套接字 4 ipv4 只显示ipv4协议的套接字 6 ipv6 只显示ipv6协议的套接字 o option 显示计时器信息(tcp的计时器) e extend 显示更多信息 Z selinux 显示进程对应selinux的上下文 高级路由传统路由基于ip地址或网络地址进行路由选择。而高级路由可以根据策略(端口、协议、网卡、报文大小等进行路由策略配置) linux系统路由表linux可以自定义从1－252个路由表 linux系统维护了4个路由表：0#表 系统保留表253#表 default table 没特别指定的默认路由都放在改表254#表 main table 没指明路由表的所有路由放在该表255#表 local table 保存本地接口地址，广播地址、NAT地址 由系统维护，用户不得更改 路由表序号和表名的对应关系在/etc/iproute2/rt_tables中，可手动编辑可以通过 ip rule查看现有策略 添加规则在添加规则时，必须先确定好“条件”、“优先级别”及“路由表ID”，此后才可以执行添加规则的操作。 条件 含义 From 源地址 To 目的地址 Tos IP包头的TOS(type of sevice) Dev Device物理接口 Fwmark iptables标签 not 取反 动作 含义 Table 指明所使用的表 Nat 网络地址转换 ip rule add from 192.168.1.10 table 10 pref=100 fwmark将fwmark作为匹配条件时，必须搭配Netfilter一起使用， 这看起来很麻烦， 却是最灵活的匹配条件。可以实现基于端口的抓那份。1234567iptables -t mangle -A FORWARD -i eth3 -p tcp --dport 80 -j MARK --set-mark 1 iptables -t mangle -A FORWARD -i eth3 -p tcp --dport 25 -j MARK --set-mark 2 iptables -t mangle -A FORWARD -i eth3 -p tcp --dport 110 -j MARK --set-mark 2 iptables -t mangle -A FORWARD -i eth3 -j MARK --set-mark 3 ip rule add fwmark 1 table 7 ip rule add fwmark 2 table 8 ip rule add fwmark 3 table 9 dev可以使用数据包输入的接口来作为判断依据。ip rule add dev eth2 table 1 优先级别我们执行ip rule show命令所显示内容的第一个字段就是优先级别，数字越小，代表优先级别越高，也代表这条规则可以排得越靠前，如此数据包在进行条件匹配时，就会越早匹配到这条规则，从输出的数据中，默认优先级别0、32766及32767已被占用，因此，在添加规则时，如果没有特别设置优先级别，那么，优先级别默认会从32766开始递减，如32765、32764……，如果我们需要特别设置优先级别，可以在ip rule add命令的最后加上prio参数 删除规则ip命令提供的删除规则的方式十分灵活，例如，要删除下列第2条规则，可以分别使用“优先级别”、“条件”及“路由表”当中任何一个唯一的值来设置所需删除的规则，如下：1234ip rule del prio 10ip rule del from 192.168.1.0/24ip rule del table 1ip rule del from 192.168.1.0/24 table 1 prio 10 路由表管理 查看路由表内容在查看路由表之前，首先使用ip rule show命令来查看目前使用了哪些路由表，接着，再使用ip route show table id | name命令来查看路由表的内容:在默认情况下，不加tale情况下显示的事main表的路由 添加路由使用ip route add命令将所需的路由添加到路由表指定表中ip route add 192.168.2.0/24 via 10.10.15.50 table main 删除路由使用ip route del命令删除路由ip route del 192.168.1.0/24 table 10]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.Linux特殊字符]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F10%2F10-Linux%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Linux下无论如何都是要用到shell命令的，在Shell的实际使用中，有编程经验的很容易上手，但稍微有难度的是shell里面的那些个符号，各种特殊的符号在我们编写Shell脚本的时候如果能够用的好，往往能给我们起到事半功倍的效果，为此，特地将Shell里面的一些符号说明罗列成对照表的形式，以便快速的查找。 特殊符号 符号 作用 例子 `` 返回子Shell查询结果并赋值给变量 dating = `date` $() 返回子Shell查询结果并赋值给变量 dating = $(date) () 进行子Shell数组 (date; echo “Hello World”) myArray=(1,2,3,4,5,6,7) (( )) 整数扩展，使用高级数学表达式使用C语言风格运算 ++,–,!,~,&lt;&lt;,&amp;,&amp;#124,&amp;&amp;,&amp;#124&amp;#124等 for (( i=1; i &lt;= 100; i++ )) [ ] 返回条件测试结果 [ a eq b] $[ ] 进行整数级运算并赋值给变量 [ $a * $b] [[ ]] 字符串高级匹配模式 [[ qualificationA &amp;&amp; qualificationB]] {} 通配符扩展在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号 touch /{a..d}.txt{echo “A”; echo “B”;} ${} 变量替换 ${variable%%&amp;/} # 注释符号(Hashmark[Comments])1.在shell文件的行首，作为shebang标记，#!/bin/bash;2. 其他地方作为注释使用，在一行中，#后面的内容并不会被执行；3. 用单/双引号包围时，#作为#号字符本身，不具有注释作用。 #! bin/bash # This Bash is to identify the differnece between then A and B ; 作为多语句的分隔符 echo “ABC”; echo “BCD” ;; 在使用case选项的时候，作为每个选项的终结符 case variable in A) echo “AAA”; echo “ BBB”;; . 1.等于source2.文件名的开头，表示该文件为隐藏文件3.目录名，一个点代表当前目录，两个点号代表上层目录4.正则表达式中，点号表示任意一个字符。 . ./.bashrc “ 双引号包围的内容可以允许变量扩展 [ -e “$filepath”] ‘ 单引号括住的内容，被视为单一字符串，引号内的禁止变量扩展，除单引号本身之外,所有字符均作为字符本身处理 echo ‘A B C’ $? 返回最后一个命令、函数、或脚本的退出状态码值，如果没有错误则是0，如果为非0，则表示在此之前的最后一次执行有错误。 echo $? $# 表示传递给脚本的参数数量 echo $# $* 将所有参数作为一个整体返回 echo $* $@ 将所有参数作为个体一次输出 echp $@ $$ 保存当前程序进程id echo $$ $! 后台运行的最后一个进程的进程ID号 echo $! - 将命令产生的结果当成文件输送到stdout中，从stdio中读取数据当成文件使用关闭文件描述符 tar -cjf - /* &amp;#124 tar -xjf - -C /usr/local exec 3&gt;&amp;- – 设置当前的命令行参数时如果参数值时”-“或”+”时也不影响,否则会被当成一个选项处理 移除信号捕获 set – “argu” “agru2” trap – SIGINT]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.字符集Locale语系]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F09%2F9-%E5%AD%97%E7%AC%A6%E9%9B%86Locale%E8%AF%AD%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[字符集字符集是一个规则集合的名字，通常包括字库表，编码字符集，字符编码方式。 字库表（character repertoire）：字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。 编码字符集（coded character set）编码字符集，用一个编码值code point来表示一个字符（即该字符在子库表中的位置），这个值称为字符对应于编码字符集（如：Unicode、ASCII）的序号。 字符编码：字符编码，是编码字符集和实际存储数值之间的转换关系。字符，是根据字符编码方案转换为一个二进制数值存储在计算机中的。所以，字符编码是定义在字符集上的映射规则。将逻辑的十六进制编码转变为计算机存储的二进制代码存储。 常用字符集及字符编码 ASCII字符集&amp;编码ASCII(American Standard Code for Information Interchange, 美国信息交换标准代码)是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。字符集范围ASCII一共定义了128个字符,包括33个控制字符,和95个可显示字符。大部分的控制字符已经被废弃。7位ASCII编码码是UTF-8编码的子集,因此当一个文件中只有英文字母和数字时，ASCII编码和UTF-8编码是相同的。扩展ASCII码，即8位ASCII码，后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展ASCII码。扩展ASCII码允许将每个字符的第8位用于确定附加的128个特殊符号字符、外来语字母和图形符号ASCII码每个字符占一个字节 GB2312字符集&amp;编码GB2312是中华人民共和国国家标准简体中文字符字符集范围GB 2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。编码格式每个汉字及符号以两个字节来表示。第一个字节称为“高位字节”，第二个字节称为“低位字节”。显然由于存放单位不同，GB2312不兼容ASCII GBK字符集&amp;编码汉字内码扩展规范，称GBK字符集GB2312-80只收录6763个汉字，有不少汉字，如部分在GB 2312-80推出以后才简化的汉字（如“啰”），部分人名用字（如中国前总理朱镕的“镕”字），台湾及香港使用的繁体字，日语及朝鲜语汉字等，并未有收录在内。GBK对GB 2312-80进行扩展, 总计拥有 23940 个码位，共收入21886个汉字和图形符号，其中汉字（包括部首和构件）21003个，图形符号883个。编码格式GBK亦采用双字节表示，GBK向下完全兼容GB2312-80编码。4.Unicode字符集&amp;UTF-8编码&amp;UTF-16编码Unicode是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。字符集Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。UTF-8编码UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与7位ASCII编码完全相同。UTF-8编码的最大长度是4个字节。UTF-16编码UTF-16编码以16位无符号整数为单位，即2个字节一个单位进行编码。UTF-32编码UTF-32编码以32位无符号整数为单位，即4个字节一个单位进行编码。 locate Internationalization(i18n)在Linux中通过locale来设置程序运行的不同语言环境。locale的命名规则为language_region.codetype如zh_CN.UTF-8，zh代表中文， CN代表中国，UTF-8表采用unicode字符集使用utf-8编码模式。在locale环境中，有一组变量，代表国际化环境中的不同设置 1、 语言符号及其分类(LC_CTYPE)用于字符分类和字符串处理，控制所有字符的处理方式，包括字符编码，字符是单字节还是多字节，如何打印等。是最重要的一个环境变量。2、 数字(LC_NUMERIC)非货币的数字显示格式3、 比较和排序习惯(LC_COLLATE)定义该环境的排序和比较规则。按照字符集的先后顺序排列。4、 时间显示格式(LC_TIME)时间和日期格式5、 货币单位(LC_MONETARY)货币格式6、 信息主要是提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES)7、 姓名书写方式(LC_NAME)8、 地址书写方式(LC_ADDRESS)9、 电话号码书写方式(LC_TELEPHONE)10、度量衡表达方式(LC_MEASUREMENT)11、默认纸张尺寸大小(LC_PAPER)12、对locale自身包含信息的概述(LC_IDENTIFICATION)。 设定locale就是设定12大类的locale分类属性，即 12个LC_。除了这12个变量可以设定以外，为了简便起见，还有两个变量：LC_ALL和LANG。它们之间有一个优先级的关系：LC_ALL &gt; LC_* &gt; LANG可以这么说，LC_ALL是最上级设定或者强制设定，而LANG是默认设定值。 配置语系Centos下修改/etc/sysconfig/i16n文件Centos下修改/ect/locale.conf和localectl命令,需要logout再次登录才能生效]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.Linux目录结构和常用配置文件]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F08%2F8-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[FHS(Filesystem Hierarchy Standard)FHS文件系统体系标准是为了规范化目录的使用而设置的标准。常用的目录标准如下表所示: 目录 全称 功能 /boot boot 放置内核文件、initrd虚拟文件系统、bootloader(grub)开机引导程序的目录,一般特别挂载一个分区 /bin Bin 命令仓库，主要放置用户在单用户模式下也可以执行的文件 /sbin System Bin 系统命令仓库,主要放置系统启动所必须用到的命令 /dev Device 设备文件,所有外部设备都是以文件的形式存放在这个目录下 /etc Etc 配置文件,主要存放系统的配置文件和服务的配置文件 /etc/init.d/ Etc Initial Directory 存放所有服务的脚本，是个目录链接，实际路径为/ect/rc.d/init.d /etc/xinetd.d Etc eXtend internet deamon directory 存放超级守护进程xinetd的配置文件 /etc/sysconfig System config 存放操作系统启动时的所需配置文件 /home Home 用户家目录 media Media 放置可删除的设备,软盘、光盘等 mnt Mount 暂时挂载的设备目录 /lib Library 存放/bin,/sbin/中命令所需要的函数库 /lost+found Lost And Found ext2以上文件系统，存放文件系统错误时丢失的数据 /porc Process 虚拟文件,数据存放在内存中，记录进程的数据、系统内核的数据等等 /sys system 虚拟文件，数据存放在内存中，记录已经加载的内核模块及内核检测的各种信息 /srv service 存放各种服务所需要的数据目录 /opt option 第三方软件目录 /var variable 存放缓存、日志等经常变动的文件 /tmp temp 暂时存放临时文件，任何人都可以访问 /usr Unix Software Resource 存放Unix操作系统软件资源 /usr/bin Unix Software Resource Bin 存放与用户单模式启动无关的命令 /usr/sbin Unix Software Resource System Bin 存放于系统启动无关的系统命令 /usr/local Locale 管理员自己安装的Unix软件 /usr/share Share 存放共享文件 /usr/src Source 存放源码文件 /var/run running 服务程序进程PID目录及所用的文件 /var/spool Spool 存放一些供其他程序使用的信息，按队列排序 /var/log Log 存放日志文件 /var/mail Mail 与/var/spool/mail互为链接文件 /var/lib Library 存放冲层序运行过程中所需要的数据文件 /var/cache Cache 系统运行过程中产生的缓存文件 常用配置文件 配置文件路径 全称 功能 /etc/passwd password 记录用户相关信息 /etc/group group 记录组相关信息 /etc/shadow shadow 记录用户密码 /etc/gshadow group shadow 记录组管理密码 /etc/inittab initial Table 设置运行等级 /etc/issue Issue tty终端启动时显示的信息，通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。 /etc/motd Message of Today 用户登录时显示的信息，内容由系统管理员确定，经常用于通告信息，如计划关时间的警告。 /etc/login.defs defualt 创建用户时有关password信息的默认属性, 部分失效属性由useradd -D设定 /etc/selinux Security Enhance Linux 安全Linux配置文件 /etc/sysconfig/network Network 可以更改hostname以及网关 /etc/resolv.conf resolve 配置DNS域名解析服务器地址 /etc/sysconfig/network-scripts/ifcfg-eth0 ifconfig eth0 配置网卡eth0的相关属性 /etc/shells shells 列出可信任的shell。chsh 命令允许用户在本文件指定范围内改变登录shell。提供一台机器FTP 服务的服务进程ftpd 检查用户shell 是否列在 /etc/shells文件中，如果不是将不允许该用户登录。 /etc/skel skeleton 设置用户默认信息的骨架文件夹 /var/log/message Message 系统的日志文件 /etc/yum.repos.d repository 配置本地YUM源 /etc/rc.d/init.d initial directory 用于放置几乎所有服务的启动脚本 /etc/sysctl.conf system control 内核参数配置文件 /etc/sysconfig/i18n internationalization的首末字符i和n，18为中间的字符数 设置系统语言和字符类型,centos7为/etc/locale.conf /etc/crontab cron table 系统定义的任务计划 /etc/anacrontab anacron table 实现检查过期和未完成的crontab的任务的配置文件 /etc/rc.d/rc.sysinit systeminit 系统启动设置配置文件 /etc/sysconfig/iptables ip tables 防火墙主配置文件 /etc/xinetd.conf extend internet deamon xinetd 的主配置文件 /etc/hosts.allow tcp hosts tcpd的一个白名单 /etc/host.deny tcp hosts tcpd的一个黑名单 /etc/cron.allow cron allow cron命令的白名单 /etc/cron.deny cron deny cron命令的黑名单 /etc/sudoers sudoers sudo命令的配置文件 /etc/fstab Filesystem Table 系统启动时自动加载的设备，（用于配置自动挂载设备）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.IFS详解]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F07%2F7-IFS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[IFS 介绍Shell 脚本中有个变量叫 IFS(Internal Field Seprator) ，内部域分隔符。完整定义是The shell uses the value stored in IFS, which is the space, tab, and newline characters by default, to delimit words for the read and set commands, when parsing output from command substitution, and when performing variable substitution.IFS是一种用户变量，当shell 处理”命令替换”和”参数替换”时，shell根据IFS 的值，默认是space,tab,newline来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。 IFS 简单实例 查看变量 IFS 的值。直接输出IFS是看不到的，把它转化为二进制就可以看到了，”040”是空格，”011”是Tab，”012”是换行符”\n” 。最后一个 012 是因为 echo 默认是会换行的。或者在set中查找也可以 12345localhost:~ glacier$ set | grep IFSIFS=$&apos; \t\n&apos;localhost:~ glacier$ echo &quot;$IFS&quot; | od -b0000000 040 011 012 012 0000004 2、$* 和 $@ 的细微差别12345678910111213141516171819202122IFS=:set -- &quot;X&quot; &quot;Y Z&quot;localhost:~ glacier$ echo &quot;$\*&quot;X:Y Zlocalhost:~ glacier$ echo $*X Y Zlocalhost:~ glacier$ echo $* |od -b0000000 170 040 171 040 172 0120000006localhost:~ glacier$ $ echo &quot;$\*&quot; |od -b0000000 170 072 171 040 172 0120000006localhost:~ glacier$ echo &quot;$@&quot;X Y Zlocalhost:~ glacier$ echo $@X Y Zlocalhost:~ glacier$ $ echo &quot;$@&quot; |od -b0000000 170 072 171 040 172 0120000006localhost:~ glacier$ $ echo $@ |od -b0000000 170 072 171 040 172 0120000006 $*变量在内存中的值是根据IFS分隔符重新组合起来,成为一个整体存储在内存中。在内存中单位是一个字符串。在命令解释时若没有引号则会根据IFS分隔符分割成不同的单词然后根据元字符(空格)隔开。$@变量将所有参数使用元字符(空格或其他字符)隔开存放在内存当中，在内存中存储单元是是数组。直接应用场景是function函数只能返回一个值，因此只能返回$* for命令for命令仍然根据空格元字符识别一次读取一个。下面差距的不同只是有没有通过第9步解析将使用IFS分割单词再按元字符空格隔开而已。 12345678910localhost:~ glacier$ for x in $var;do echo $x;done abclocalhost:~ glacier$ for x in &quot;$var&quot;;do echo $x;done a b clocalhost:~ glacier$ for x in &quot;$var&quot;;do echo &quot;$x&quot;;done: a:b:c:]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.Shell命令解析过程]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F06%2F6-Shell%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Shell命令解析顺序: 将命令行分成由固定元字符集分隔的记号；SPACE, TAB, NEWLINE, ; , (, ),&lt;, &gt;, |,&amp;记号类型包括单词，关键字，I/O重定向符和分号。 检测每个命令的第一个记号，查看是否为不带引号或反斜线的关键字。如果是一个开放的关键字，如if和其他控制结构起始字符串，function，{或(，则命令实际上为一复合命令。shell在内部对复合命令进行处理，读取下一个命令，并重复这一过程。如果关键字不是复合命令起始字符串(如then等一个控制结构中间出现的关键字)，则给出语法错误信号。 依据别名列表检查每个命令的第一个关键字；如果找到相应匹配，则替换其别名定义，并退回第一步;否则进入第4步。该策略允许递归别名，还允许定义关键字别名。如alias procedure=function 执行大括号扩展，例如a{b,c}变成ab ac 如果~位于单词开头，用$HOME替换~。使用usr的主目录替换~user。 对任何以符号$开头的表达式执行参数(变量)替换; 对形式$(string)的表达式进行命令替换；这里是嵌套的命令行处理。 计算形式为$((string))的算术表达式； 把行的参数，命令和算术替换部分再次分成单词，这次它使用$IFS中的字符做分割符而不是步骤1的元字符集，然后将分割后的单词按步骤一的元字符集(空格)展开 对出现*, ?, [ / ]对执行路径名扩展，也称为通配符扩展； 按命令优先级表(跳过别名)，进行命令查寻； 设置完I/O重定向和其他操作后执行该命令。 当一次解析无法满足要求是可以通过eval进行上述1-11步骤2遍再进行12步骤。比如说context=”for ..”; $context; 由于执行顺序原因第一遍没有检查到关键词，因此无法执行所以需要eval $context 关于引用1、单引号跳过了前10个步骤，不能在单引号里放单引号2、双引号跳过了步骤1~5，步骤9~10，也就是说，只处理6~8个步骤。也就是说，双引号忽略了管道字符，别名，~替换，通配符扩展，和通过分隔符分裂成单词。双引号里的单引号没有作用，但双引号允许参数替换，命令替换和算术表达式求值。可以在双引号里包含双引号，方式是加上转义符”\”，还必须转义$,`, \。 举例说明:12345678910111213141516171819202122IFS=:set -- &quot;X&quot; &quot;Y Z&quot;localhost:~ glacier$ echo &quot;$\*&quot;X:Y Zlocalhost:~ glacier$ echo $*X Y Zlocalhost:~ glacier$ echo $* |od -b0000000 170 040 171 040 172 0120000006localhost:~ glacier$ $ echo &quot;$\*&quot; |od -b0000000 170 072 171 040 172 0120000006localhost:~ glacier$ echo &quot;$@&quot;X Y Zlocalhost:~ glacier$ echo $@X Y Zlocalhost:~ glacier$ $ echo &quot;$@&quot; |od -b0000000 170 072 171 040 172 0120000006localhost:~ glacier$ $ echo $@ |od -b0000000 170 072 171 040 172 0120000006 $*变量在内存中的值是根据IFS分隔符重新组合起来,成为一个整体存储在内存中。在内存中单位是一个字符串。 因此当双引号存在时，并不会进行第9步把行的参数，命令和算术替换部分再次分成单词，这次它使用$IFS中的字符做分割符。因此直接输出X:Y Z而在不加入双引号时，会进行第9步把行的参数，命令和算术替换部分再次分成单词，将其分为2个单词”X” “Y Z”,然后通过元字符展开为X Y Z。 $@变量将所有参数使用元字符(空格或其他字符)隔开存放在内存当中，在内存中存储单元是是数组。 因此了解$*代表一个字符串变量，而$@代表一个数组了吧。虽然在不加双引号时，显示在终端上，会步骤会进行第9步的操作。导致$@与$值显示的事相同的。但是在非显示状态进行数值的判断时时直接从内存中寻找对应的值和类型来进行判断的。因此会造成一些不同。直接应用场景是function函数只能返回一个值，因此只能返回${array[*]}或$* 又例如数组的使用场景数组在定义时时通过元字符空格来确定每个元素的值，而不是通过IFS来确定每个元素的值。下面这个例子更能体现$*与$@的区别 123456789101112localhost:~ glacier$ IFS=,localhost:~ glacier$ array=(1.2,3 2.3,4 5.6,7)localhost:~ glacier$ echo $&#123;#array[@]&#125;3localhost:~ glacier$ echo $&#123;array[*]&#125;1.2 3 2.3 4 5.6 7localhost:~ glacier$ echo &quot;$&#123;array[*]&#125;&quot;1.2,3,2.3,4,5.6,7localhost:~ glacier$ echo $&#123;array[@]&#125;1.2 3 2.3 4 5.6 7localhost:~ glacier$ echo &quot;$&#123;array[@]&#125;&quot;1.2,3 2.3,4 5.6,7]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.环境变量]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F05%2F5-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[定义环境变量是在操作系统中具有一个特定名字的对象，它包含了一个或多个应用程序所将要使用到的信息。环境变量相当于给系统或用户应用程序设置的一些参数，具体什么作用这当然和具体的环境变量有关。linux是一个多用户的操作系统，每个用户登录系统之后，都会有一个专用的运行环境。通常每个用户默认的环境都是相同的，这个默认的环境实际上就是一组环境变量的定义。用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。 分类linux的变量分为环境变量和本地变量： 环境变量是一种全局变量，存在所有的shell中，在登录的时候就有系统定义的环境变量了，子shell会继承父shell的环境变量，且子shell环境变量的改变不影响父shell的环境变量。 本地变量:当前shell中的变量，本地变量中包含环境变量。linux的本地变量的非环境变量不具备继承性。 在linux下面的变量按照生存周期可分为两类： 1、永久的：需要修改配置文件，变量永久的生效。2、临时的：使用export命令声明即可，变量在关闭shell时失效。 常见的环境变量有: PATH：指定命令的搜索路径 HOME：指定用户的主工作目录(即用户登录到Linux系统时，默认的目录) HISTSIZE：保存历史命令记录的条数 LOGNAME：显示当前用户的登录名 HOSTNAME:指主机的名字，应用程序要是用到主机名的话就是从这个变量中获取的 SHELL:指当前用户使用的是那种Shell MALL:指当前的用户邮件存放的目录 PS1：命令基本提示符 PS2：附属提示符，默认是”&gt;” 常用用户变量: IFS: 内部字段分隔符，默认是空格，该变量在编写shell脚本是非常常用，通过修改IFS的值可以修改字段之间判断的标准 Instruction在环境变量中要特别注意一点子shell会继承父shell的环境变量，且子shell环境变量的改变不影响父shell的环境变量。 常用环境变量指令 export declare readonly env set unset export命令按定义格式输出所有的环境变量1234567localhost:~ glacier$ export declare -x Apple_PubSub_Socket_Render=&quot;/private/tmp/com.apple.launchd.gDKb65Sxnp/Render&quot;declare -x HOME=&quot;/Users/glacier&quot;declare -x LC_CTYPE=&quot;UTF-8&quot;declare -x LOGNAME=&quot;glacier&quot;declare -x OLDPWDdeclare -x PATH=&quot;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin 将用户变量非环境变量转变为环境变量1234localhost:~ glacier$ pathway=/usr/local/localhost:~ glacier$ export pathwaylocalhost:~ glacier$ export | grep pathwaydeclare -x pathway=&quot;/usr/local/&quot; declare注意:shell语言是解释型语言,变量在使用前可以无需定义。但使用declare可以实现固定变量的类型。 declare [option] [variable] option total meaning 含义 -i integral 将变量定义为整形 -a array 将变量定义为数组 -x exprot 将变量转变为环境变量,注意变量不管有没有设定过都能转变为环境变量 +x oppsite exprot 环境变量转变为用户非环境变量 -r readonly 将变量定义为只读型,注意修改为只读型后无法再取消 1234567localhost:~ glacier$ declareApple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.gDKb65Sxnp/RenderBASH=/bin/bashBASH_ARGC=()BASH_ARGV=()BASH_LINENO=()BASH_REMATCH=([0]=&quot;r&quot;) 1234567localhost:~ glacier$ declare -i intergrallocalhost:~ glacier$ intergral=1localhost:~ glacier$ echo $intergral1localhost:~ glacier$ intergral=stringlocalhost:~ glacier$ echo $intergral0 1234localhost:~ glacier$ declare -a arraylocalhost:~ glacier$ array=(1 2 3 4)localhost:~ glacier$ echo $&#123;array[\*]&#125;1 2 3 4 1234567localhost:~ glacier$ lovariable=/usr/local/localhost:~ glacier$ export | grep lovariablelocalhost:~ glacier$ declare -x lovariablelocalhost:~ glacier$ export | grep lovariabledeclare -x lovariable=&quot;/usr/local/&quot;localhost:~ glacier$ declare +x lovariablelocalhost:~ glacier$ export | grep lovariable 12345localhost:~ glacier$ declare -r mon=1localhost:~ glacier$ echo $mon1localhost:~ glacier$ mon=2-bash: mon: readonly variable readonly将变量定义为只读型,注意修改为只读型后无法再取消 12345localhost:~ glacier$ readonly mom=1localhost:~ glacier$ echo $mom 1localhost:~ glacier$ mom=2-bash: mom: readonly variable env显示当前用户Shell的环境变量 localhost:~ glacier$ envTERM_PROGRAM=Apple_TerminalSHELL=/bin/bashTERM=xterm-256color 5.set 查看当前用户变量12345678localhost:~ glacier$ setApple_PubSub_Socket_Render=/private/tmp/com.apple.launchd.gDKb65Sxnp/RenderBASH=/bin/bashBASH_ARGC=()PWD=/Users/glacierSHELL=/bin/bashIFS=$&apos; \t\n&apos;LC_CTYPE=UTF-8 unset删除变量 localhost:~ glacier$ declare variable=kkklocalhost:~ glacier$ echo $variablekkklocalhost:~ glacier$ unset variablelocalhost:~ glacier$ echo $variable 配置文件 login_shell在登录时必须要进行完整的登录验证流程的成为登录shell。依次读取如下配置文件 /etc/profile(系统整体配置文件,profile中会根据用户是否为root用户加载不同的PATH，用户名，邮件变量) /etc/inputrc(判断有无自定义按键，若没有则会加载默认的这个文件，各种热键) /etc/profile.d/*.sh(按功能各自的配置文件) /etc/sysconfig/i18n(决定bash使用的语系) ~/.bash_profile、~/.bash_login、~/.profile(按顺序三者选一，其中为用户自定义的环境变量，把~/bin加入到PATH路径中) ~/.bashrc(~/.bash_profile会读取~/.bashrc中的信息) /ect/bashrc(设置系统除PATH之外的环境变量) no-login_shell ~/.bashrc /ect/bashrc(设置系统除PATH之外的环境变量) /etc/profile.d/*.sh(按功能各自的配置文件) 因此在su切换环境是不加-或-l选项改变loginshell则系统使用no-login_shell会造成不加载/etc/profile,PATH,用户及邮箱环境变量仍然是原来的变量。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.CentOS7启动流程]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F04%2F4-CentOS7%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[systemd简介开机流程 POST –&gt; Boot Sequence –&gt; Bootloader –&gt; kernel + initramfs(initrd) –&gt;rootfs –&gt; /sbin/initinit: init类别 CentOS 5: SysV initCentOS 6: UpstartCentOS 7: Systemd Systemd：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程Systemd新特性：系统引导时实现服务并行启动按需启动守护进程自动化的服务依赖关系管理同时采用socket式与D-Bus(deamon Bus)总线式激活服务(既可以网络通讯激活也可以本地应用程序通讯激活)系统状态快照 unit对象unit表示不同类型的systemd对象，通过配置文件进行标识和配置；文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息配置文件： 目录 内容 /usr/lib/systemd/system 每个服务最主要的启动脚本设置，类似于之前的/etc/init.d/ /run/systemd/system 系统执行过程中所产生的服务脚本 /etc/systemd/system 管理员建立的执行脚本 优先级/etc/systemd/system &gt; /run/systemd/system &gt; /usr/lib/systemd/system 如果要修改或覆盖/usr/lib/systemd/system下的配置文件可以 unit类型Service unit: 文件扩展名为.service, 用于定义系统服务Target unit: 文件扩展名为.target，用于模拟实现运行级别Device unit: .device, 用于定义内核识别的设备Mount unit: .mount, 定义文件系统挂载点Socket unit: .socket, 用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动Snapshot unit: .snapshot, 管理系统快照Swap unit: .swap, 用于标识swap设备Automount unit: .automount，文件系统的自动挂载点Path unit: .path，用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务，如：spool 目录 特性关键特性：基于socket的激活机制：socket与服务程序分离基于d-bus的激活机制：基于device的激活机制：基于path的激活机制：系统快照：保存各unit的当前状态信息于持久存储设备中向后兼容sysv init脚本 不兼容：systemctl命令固定不变，不可自定义参数非由systemd启动的服务，systemctl无法与之通信和控制 service unit文件格式在/etc/systemd/system下的unit文件是系统管理员和用户使用在/usr/lib/systemd/system下的供发行版打包者使用 在unit文件中，以“#” 开头的行后面的内容会被认为是注释，相关布尔值，1、yes、on、true 都是开启，0、no、off、false 都是关闭，时间单位默认是秒，所以要用毫秒（ms）分钟（m）等须显式说明 service unit file[Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等[Service]：定义Unit启动相关的选项，例如启动方式、脚本路径等[Install]：定义由“systemctl enable”以及”systemctl disable“命令在实现服务启用或禁用时用到的一些选项 unit段的常用选项Description：描述信息After：定义unit的启动次序，表示当前unit应该晚于哪些unit启动，其功能与Before相反Requires：依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活Wants：依赖到的其它units，弱依赖Conflicts：定义units间的冲突关系 Service段的常用选项Type：定义影响ExecStart及相关参数的功能的unit进程启动类型 simple：默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中 forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止 oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中 dbus：与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行 notify：在启动完成后会发送一个通知消息。还需要配合6. 6. NotifyAccess 来让Systemd 接收消息 idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务 EnvironmentFile：环境配置文件ExecStart：指明启动unit要运行命令或脚本的绝对路径ExecStartPre：ExecStart前运行ExecStartPost：ExecStart后运行ExecStop：指明停止unit要运行的命令或脚本Restart：当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务 install段的常用选项Alias：别名，可使用systemctlcommand Alias.serviceRequiredBy：被哪些units所依赖，强依赖WantedBy：被哪些units所依赖，弱依赖Also：安装本服务的时候还要安装别的相关服务 注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载此配置文件,而后可以选择重启 systemctl daemon-reload 重新扫描unit配置文件 管理服务管理系统服务除了使用命令启动外，可以直接通过程序启动。不过centos7直接通过程序启动则不会受到systemd的管控。centos6服务一般放置在/etc/rc.d/init.d/下，可以直接找到对应服务文件启动。centos7服务一般存在/usr/sbin|/usr/bin/|/bin/|/sbin/下，管理员只需要在/usr/lib/systemd/system/或/etc/syste md/system/下增加unit配置文件，在配置文件中给出需要执行的命令的路径和各种依赖及属性即可。 centos6保存了各个运行级别的各程序的启动和关闭，通过/etc/rc#.d/下文件名开头K,S辨别。centos7通过在/etc/systemd/system/#.target.wants/下创建链接在保存启动的程序。 动作 Centos6 Centos7 启动 service deamon start systemctl start deamon 停止 service deamon stop systemctl stop deamon 重启 service deamon restart systemctl restart deamon 状态 service deamon status systemctl status deamon 重载配置文件 service deamon reload systemctl reload deamon 条件式重启(已启动才重启) service deamon condrestart systemctl try-restart deamon 重载或重启服务(如果无法重载则重启,否则重载) - systemctl tyr-or-restart deamon 重载或条件式重启服务 - systemctl tyr-or-try-restart deamon 禁止自动和手动启动 - systemctl mask deamon(实际是添加空的unit文件链接) 取消禁止 - systemctl unmask deamon(实际是删除空链接) 设定某服务开机自启 chkconfig deamon on systemctl enable deamon 设定某服务开机禁止启动 chkconfig deamon off systemctl disable deamon 查看所有服务的开机自启状态 chkconfig –list systemctl list-unit-files –type service 查看服务是否开机自启 chkconfig –list systemctl is-enabled name.service 获得和修改默认运行级别 /etc/inittab/ systemctl get-default, systemctl set-default #.target or /etc/systemd/system/default.target 实际set-default命令是增加了两个软链接 直接修改运行级别 ctrl + alt + F1-F7 or init 0-6 systemctl isolate #.target(必须target配置文件中Allowisolate=yes才行) 杀死服务 kill -signal deamon systemctl kill –signal 1-64 deamon 查看服务的依赖关系 - systemctl list-dependencies name.service 服务状态loaded:Unit配置文件已处理active(running):一次或多次持续处理的运行active(exited):成功完成一次性的配置active(waiting):运行中，等待一个事件inactive:不运行enabled:开机启动disabled:开机不启动static:开机不启动，但可被另一个启用的服务激活 CentOS7引导顺序 UEFi或BIOS初始化，运行POST开机自检 选择启动设备 引导装载程序, centos7是grub2 加载装载程序的配置文件：/etc/grub.d/ /etc/default/grub /boot/grub2/grub.cfg 加载initramfs驱动模块 加载内核选项 内核初始化，centos7使用systemd代替init 执行initrd.target所有单元，包括挂载/etc/fstab 从initramfs根文件系统切换到磁盘根目录 systemd执行默认target配置，配置文件/etc/systemd/system/default.target systemd执行sysinit.target初始化系统及basic.target准备操作系统 systemd启动multi-user.target下的本机与服务器服务 systemd执行multi-user.target下的/etc/rc.d/rc.local Systemd执行multi-user.target下的getty.target及登录服务 systemd执行graphical需要的服务 Grub修改密码与centos6进入单用户模式runlevel1不同,centos7进入紧急模式runlevel仍然需要root密码设置内核参数，只影响当次启动，但是仍然需要root密码启动时，在linux16行后添加systemd.unit=emergency.target或systemd.unit=rescue.targetrescue.target比emergency支持更多的功能，例如日志等。 因此在centos7下修改root密码有2中方法。 在挂载完毕虚拟文件系统后停止。手动挂载根文件系统。然后修改root密码。 将只读模式挂载根文件系统执行init程序修改为可读写模式执行/bin/sh来修改密码。 两者的共同点都是用读写方式挂载根文件系统，且都不执行init程序。两者的区别在于系统启动不同阶段，中间差了一个挂载 方法一 在linux16行后添加 rd.break(命令其在加载完虚拟文件系统后停止) mount –o remount,rw /sysroot(读写方式挂载根) chroot /sysroot (切换根文件系统) /bin/passwd root 修改密码 touch /.autorelabel(让selinux重新对整个文件系统进行relabeling,否则由于修改了对应的密码文件，导致selinux的原因无法读取密码文件，会使系统没法运行) 方法二 在linux16行后添加 rw init=/sysroot/bin (读写模式挂载且修改第一个程序为bin程序) chroot /sysroot passwd root touch /.autorelabel]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.CentOS6启动流程]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F03%2F3-CentOS6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Linux启动流程 第一步:硬件引导启动 用户打开电源 BIOS(Basic Input Output System)，首先开机自检POST(Power On And Self Test)，初始化硬件设备，检查系统的各项设备，确定无硬件问题后，根据BIOS设定的启动顺序，启动设备，如果硬盘是启动项的话，会读取该硬盘第一个扇区的内容MBR主引导记录(Master Boot Record)(512Byte) MBR分为三部分,bootloader(446Byte)、partition(16*4byte),magic digit(2byte)(标志这个扇区为MBR),在linux中一般bootloader为GRUB或LILO。第二步：GRUB引导启动内核由于446字节太小，不够运行完整的grub,因此bootloader中只是存放了grub.stage1。grub一般分为stage1、stage1.5、stage2三个阶段，各自执行各自的功能。 Stage1阶段：Stage1阶段其实就是执行系统安装时预先写入到MBR的Bootloader中的程序。Stage1阶段的任务仅是将硬盘0柱面0磁道2扇区的内容读入内存并执行，它是Stage1.5阶段或Stage2阶段的入口，引导进入Stage1.5阶段或Stage2阶段。在此Stage1阶段，还没有识别文件系统的能力。 Stage1.5阶段stage1.5阶段是stage1阶段和stage2阶段的中间桥梁。加载到内存的第二个扇区的内容是由GRUB源码stage/start.S汇编而成，这个汇编文件汇编出来的二进制文件大小也是512B，一个扇区的大小。接下来就要说明Stage1.5阶段的作用了。 首先注意到Centos的操作系统内核存储在/boot/目录下，而/boot/目录挂载了ext4文件系统，因此我们要读取操作系统内核，首先我们必须要载入ext4文件系统，否则我们根本无法读取系统内核文件。因此Stage1.5阶段的作用就不言而喻了，那就是从第二个扇区开始的N个扇区中读取/boot/分区所属的文件系统驱动。我们可以看到/boot/grub下有各种文件系统类型的文件,一般我们在使用外部硬盘安装系统时，grub会判断/boot文件夹挂载的分区的文件系统格式,一般而言是ext,因此会选择/boot/grub/e2fs_stage1_5文件,将其连续的放入内存中，以便计算机能够载入文件系统，从而载入内核，因此这时硬盘的第二个扇区的内容和/boot/grub/e2fs_stage1_5文件的前512字节一样，这部分内容是有grub源码/stage2/start.S汇编出的，而这个start.S的作用就是加载磁盘的第三个扇区到第N个扇区到内存，N取几，取决与文件系统的支撑代码的大小。 stage1.5将文件系统载入后，计算机就具有识别/boot/分区文件系统的能力，这时此后GRUB程序便有能力去访问/boot分区下/grub目录下的 stage2文件，并将stage2载入内存执行。 注意:通过上述说明可以知道,在grub阶段，文件系统的根目录是在/boot/下的，因此访问内核文件时的路径也就是相对/boot/下的根路径，这也就能理解为什么grub.conf中操作系统内核的路径是/vmlinuz….了。 C．Stage2阶段Stage2阶段执行时，首先会解析GRUB程序的配置文件grub.conf，并依配置文件决定是否显示系统启动菜单。然后加载内核镜像到内存中，通过initrd程序建立RAMDisk内存虚拟根文件系统。此时控制权将转交给内核程序。 第三步：内核引导启动 这一部分主要是通过在内存中建立虚拟根文件系统实现相关设备的驱动并建立和切换到真正的根文件系统。 思考下为什么要建立虚拟根文件系统呢？问题:现如今的文件种类繁多，微内核设计为了精简因此不可能将所有文件系统的驱动嵌入到内核当中，因此怎么能够保证程序能够100%的读取硬盘的文件系统并将其挂载到根目录下呢？解决办法: 微内核仍然具有一种文件系统的驱动，而通过这个文件系统去加载一个虚拟根文件系统，该文件系统中包括其他所有文件系统的驱动程序，然后微内核通过识别设备中的文件系统信息加载对应的文件系统驱动。 微内核中不包含所有的文件系统驱动，通过bootloader程序将中介文件系统驱动的连续的存放在磁盘前几个扇区之中，linux在启动过程中通过读入驱动来读取虚拟根文件系统。然后微内核通过识别设备的文件系统信息在虚拟根文件系统加载对应的文件系统驱动。 在实际过程是通过1与2方法结合的方式使用微内核仍然具有一种文件系统的驱动(一般是ext),bootloader程序将中介文件系统驱动的连续的存放在磁盘前几个扇区之中，如果设备的文件系统正好是ext则不加载initrd虚拟文件系统直接读取设备文件系统加载根，否则则先加载虚拟根文件系统，读入设备的文件驱动来读取内核所在分区。 linux文件系统驱动程序都作为模块都放置在/lib/module文件夹中。根文件系统可以多种多样，例如ext3、fat32、ntfs等等。/lib/moudle文件夹下的内容也不是连续存放在硬盘中的，而是根据各自文件系统的存储方式，分散存储在各个存储单元中，因此当操作系统内核没有对应文件系统的驱动时，根本没法读取真正/lib/module中的驱动，因此也没办法读取真正的根文件系统。因此这时就需要一个中介系统，那就是虚拟根文件系统，虚拟根文件系统中存放了各种文件系统的驱动，而内核中也只要存储一个虚拟根文件系统的驱动即可，即保持了微内核的精简也达到了启动的目的。 initrd(initial RAM Disk)程序建立RAMDisk内存虚拟根文件系统后，内核开始驱动基本硬件，并调用虚拟根文件系统中的init程序加载驱动模块初始化系统中各种设备的相关配置工作，其中包括CPU、I/O、存储设备等。当所需的驱动程序加载完后，会根据grub.conf配置文件中“root=XXX”部分所指定的内容创建一个根设备，然后将根文件系统以只读的方式挂载(为了防止启动过程中发生错误导致根文件系统崩溃)，并切换到真正的根文件系统上，同时调用系统进程的老祖宗进程/sbin/init程序，进入系统初始化阶段。 第四步：系统初始化 这一步是通过/sbin/init,init程序准备软件运行坏境，启动系统服务。在内核初始化的最后，内核将启动pid为1的init进程，即 UpStart进程。UpStart解决了之前sysvinit的缺点。采用事件驱动模型，UpStart可以：更快地启动系统、当新硬件被发现时动态启动服务、硬件被拔除时动态停止服务。Upstart 进程在执行了一些自身的初始化工作后，立即发出”startup”事件。上图中用红色方框加红色箭头表示事件，可以在左上方看到”startup”事件。所有依赖于”startup”事件的工作被触发，其中最重要的是 mountall。mountall 任务负责挂载系统中需要使用的文件系统，完成相应工作后，mountall任务会发出以下事件：local-filesystem，virtual-filesystem，all-swaps，其中 virtual-filesystem事件触发udev任务开始工作。任务 udev触 upstart-udev-bridge的工作。Upstart-udev-bridge会发出net-device-up IFACE=lo事件，表示本地回环 IP 网络已经准备就绪。同时，任务mountall继续执行，最终会发出 filesystem 事件。此时，任务 rc-sysinit会被触发，因为 rc-sysinit的start on条件如下：start on filesystem and net-device-up IFACE=lo任务 rc-sysinit 调用 telinit。Telinit 任务会发出 runlevel事件，触发执行/etc/init/rc.conf。rc.conf 执行/etc/rc$.d/目录下的所有脚本 rc全称为running command 通过/etc/inittab文件确定运行级别，然后去执行系统初始化脚本/etc/rc.sysinit,为用户初始化用户空间环境，在完成初始化后，根据运行级别，系统开始对应级别的目录启动服务，关闭那些不要的服务（里面S99local -&gt; ../rc.local）用户自动服务启动脚本 默认运行级别/etc/inittab文件设置系统启动的默认级别 inittab文件设置了默认运行级别0：关机，shutdown1：单用户模式（single user），root用户，无须认证，维护模式；2：多用户模式（multi user），会启动网络功能，但不会启动NFS，维护模式；3：多用户模式（multi user），完全功能模式，文本界面；4：预留级别：目前无特别使用目的，但习惯以同3级别功能使用；5：多用户模式（multi user），完全功能模式，图形界面；6：重启，reboot 不同的级别主要区别是启动不同的脚本,在/etc/rc.d/rc#.d下 系统初始化脚本：/etc/rc.sysinit （1）设置主机名；（2）设置欢迎信息；（3）激活udev和selinux；（4）挂载/etc/fstab文件中定义的所有文件系统；（5）检测根文件系统，并以读写方式重新挂载根文件系统；（重新挂载是指根文件检测完之后）（6）设置系统时钟；（7）根据/etc/sysctl.conf文件来设置内核参数；（8）激活lvm即软raid设备；（9）激活swap设备；（10）加载额外设备的驱动程序；（内核加载驱动只加载根文件系统的）（11）清理操作； 脚本文件/etc/rc.d/脚本文件/etc/rc.d/rc作用为当级别切换时启动或停止服务；此脚本接受传递的参数给脚本中$runlevel变量，然后，读取/etc/rc$runlevel.d/K*和/etc/rc$runlevel.d/S*所有文件，这些文件就是为什么开机启动后，有些服务会自动启动，有些服务没有启动的原因。K*：要停止的服务，K##*，优先级，数字越小，越优先关闭，依赖的服务先关闭，然后再关闭被依赖的。S*：要启动的服务，S##*，优先级，数字越小，越是优先启动，被依赖的服务先启动，而依赖的服务后启动。这些文件都是链接文件，它们链接到了/etc/init.d/*目录下的各个程序的。一般可以使用chkconfig命令实现设置某一服务下次重启系统后是该关闭或者开启，该命令的本质也就是修改对应文件夹下的文件名。此外当用户需要自定义开机启动程序，可以根据自己的需求将一些执行命令或是写到脚本/etc/rc.d/rc.local.当开机时就可以自动加载啦！ 第五步：启动终端，用户登录shell 这一步是用户登录shell过程如果没有改变级别，默认情况执行/sbin/mingetty打开6个纯文本终端，让用户输入用户名和密码。输入完成后，再调用login程序，核对密码。如果密码正确，就从文件 /etc/passwd 读取该用户指定的shell，然后启动这个shell。 Grub配置 default=0 #设定默认启动菜单项，默认为0开始timeout=5 #指定菜单等待选择的时长splashimage=(hd0,0)/grub/splash.xpm.gz #指定菜单的背景图片的路径，为xpm格式，采用gzip压缩hiddenmenu #是否影藏菜单password –md5 $1$1S9Xy$1MuGZSoPc2vAtkW.jvz0X/ #菜单编辑认证title CentOS 6 (2.6.32-642.el6.x86_64) #定义菜单项password 123456 #可以选择明文root (hd0,0) #本次grub查找stage2及其kernel文件所在设备分区，指定grub的根kernel /vmlinuz-2.6.32-642.el6.x86_64 ro root=UUID=240533cf-b37f-4460-974f-702bab867da5 nomodeset rd_NO_LUKS KEYBOARDTYPE=pc KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet #需要启动的内核initrd /initramfs-2.6.32-642.el6.x86_64.img #内核匹配的ramfs文件 通常当用户忘记root密码是可以通过修改grub进入single模式修改密码，为了不让用户随意修改密码，可以对grub进行密码加密，由于密码是明文存放在grub.conf中的，我们也可以使用grub-md5-crypt对密码进行md5加密 chkconfig命令chkconfig命令检查、设置系统的各种服务。chkconfig有自己的数据库保存对应的数据，因此并非所有在/ect/rc.d/init.d目录下的服务脚本都会在chkconfig下出现。需要chkconfig –add servicename,才能使用chkconfig同一管理，说到底chkconfig是个管理工具而已。/etc/init.d/目录软连接到/etc/rc.d/init.d/目录下目录下所有的服务脚本文件都有下列2行#chkconfig: 2345 20 80第一个数字代表默认运行的优先级,也就是在那几个/ect/rc#.d/目录下创建文件。第二个数字代表S(start)开头文件的默认优先级,即S20第三个数字代表K(kill)开头文件的默认优先级,即K80#description: Saves and restores system entropy pool for 命令的工作原理: chkconfig –list 列出所有的系统服务。 1.从自身数据库中查找对应的服务在各个级别的默认开启情况 chkconfig –add servicename 1.从/ect/init.d/目录下找到对应的服务脚本。2.解析服务脚本中的chkconfig行中的参数,根据对应的参数在/etc/rc.d/rcN.d中创建K/S文件。 chkconfig –level 35 mysqld on修改服务的默认启动等级。 1.直接修改自身数据库中的35运行为开启。并非修改/ect/init.d/对应的服务脚本的内容。2.修改/etc/rc.d/rcN.d/中的文件名，K改S。 chkconfig –del httpd 删除httpd服务。 删除/etc/rc.d/rcN.d/中的服务链接文件,并不删除/ect/init.d/对应的服务脚本。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.Vim快捷键]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F02%2F2-Vim%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[移动类Normal模式下: 操作 助记 含义 j 光标下移 k 光标上移 h 光标左移 l 光标右移 $ 光标移至行尾 0 光标移至行首 ^ 光标移至行第一个非空字符 b Begin 光标移至当前单词词首,大写B忽略标点符号为分隔符 e End 光标移至当前单词词尾,大写E忽略标点符号为分隔符 w Word 光标移至下一个单词词首,大写W忽略标点符号为分隔符 () 光标移到上下一句的句首。句子以回车或句号为结尾。 {} 光标移到上下一段落的端首。段落以回车为结尾 Ctrl + f forward 光标向下翻一页 Ctrl + b backward 光标向上翻一页 Ctrl + u Up 光标向上翻半页 Ctrl + d Down 光标向下翻半页 跳跃类 操作 助记 含义 :jump Jump 显示光标可跳跃的点 Ctrl + o 跳跃到上一个跳跃点 Ctrl + i 跳跃到下一个跳跃点 匹配类 操作 助记 含义 % 匹配对应的(),{},[]需要光标在其中一个上使用 数字加减 操作 助记 含义 Ctrl + a Add 数字加一 Ctrl + x 数字减一 折叠类 操作 助记 含义 Ctrl + f 根据规则自动创建折叠 or Under V model :begin,endfo 在两行中创建折叠 zd zip delete 删除光标下折叠 zD zip Delete 迭代删除光标下的子折叠 zE 删除光标所在窗口的所有折叠 zo zip open 打开光标所在窗口的折叠 zO zip Open 迭代打开光标所在窗口的子折叠 zc zip close 关闭光标所在窗口的折叠 zC zip close 迭代关闭光标所在窗口的子折叠 za zip alter 当光标在关闭折叠上时，打开之。在打开折叠上时，关闭之 zA zip alter 当光标在关闭折叠上时，迭代打开之。在打开折叠上时，迭代关闭之 Zr 打开一层折叠 Zm 关闭一层折叠 ZR 打开所有折叠 ZM 关闭所有折叠 zj zip J 移到下一个折叠 zk zip K 移动到上一个折叠 [z 移动到当前折叠头 ]z 移动到当前折叠尾 窗口类 操作 助记 含义 Ctrl + w + n Window + New 创建一个窗口 Ctrl + w q Window + Quit 退出当前窗口 Ctrl + w hjkl Window + hjkl 移动到左下上右窗口 Ctrl + w o Window + Open 将当前窗口最大化 :files 显示目前打开了哪些文件 :buffers 显示目前存在几个缓冲区 :bn buffer next 下一个缓冲区内容 :bp buffer previous 上一个缓冲区内容 :buffer N 切换到第N个缓冲区 :sp [filename] / Ctrl + w + s 水平打开一个新的缓冲区，如果有filename则内容为该文件，否则为当前文件 :vs [filename] / Ctrl + w + v 垂直打开一个新的缓冲区，如果有filename则内容为该文件，否则为当前文件 替换类:[range]s/origin/update/[option] range 含义 . 当前行 % 整个文件 $ 末尾行 begin,end 两行中间 option 助记 含义 g globle 全局替换,若没有代表只对第一匹配进行更改 c certify 确认核实 撤销与重做 操作 助记 含义 u Undo 撤销操作 Ctrl + R Redo 重做操作 删除类 操作 助记 含义 dd 删除光标所在行 dj 删除光标所在下一行 dk 删除光标所在上一行 ndd 删除从光标所在行开始，向下的n行 dw 删除光标到下一个单词之前的部分 de 删除光标到本单词末尾的部分 db 删除光标前一位到单词首部 d1G 删除从光标所在行开始，到第一行的所有行 dG 删除从光标所在行开始，到最后一行的所有行 d$ 删除从光标所在位置，到行尾的所有字符 d0 删除从光标所在位置，到行首的所有字符 :n1,n2d 删除n1行到n2行之间的行 :1,10m20 将第1-10行按末尾移动第20行 x 删除字符 diw Delete inner Word 删除内含单词 daw Delete a Word 删除一个单词 dis Delete inner sentence 删除内含句子 das Delete a sentence 删除一个句子 dib Delete inner Block 删除内含 ‘(‘ ‘)’ 块 dab Delete inner Block 删除一个 ‘(‘ ‘)’ 块 dip Delete inner paragraph 删除内含段落 dap Delete a paragraph 删除一个段落 diB Delete inner Block 删除内含 ‘{ ‘ ‘ }’ 大块 daB Delete a Block 删除一个 ‘{ ‘ ‘ }’ 大块 列模式 操作 助记 含义 v;up,down;: visual 进入列模式选中行,然后按冒号可以进行人工选择列的替换操作 ctrl+v;up,down;I;input string;ese Block 块模式进行多列插入 ctrl+v;up,down;d Block 块模式进行多列删除]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.Bash快捷键]]></title>
    <url>%2FglacierBlog.github.io%2F2018%2F10%2F01%2F1-Bash%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[移动类 快捷键 含义 用途 Ctrl + a ahead 将光标移动至首部 Ctrl + e end 将光标移至尾部 Ctrl + xx 将光标在首部至当前位置来回移动 Ctrl + f forward 将光标向前移动 Ctrl + b backward 将光标向后移动 Alt + f forward 将光标向前移动一个单词 Alt + b backward 将光标向后移动一个单词 删除类 快捷键 含义 用途 Ctrl + d delete 删除光标位置字符 Ctrl + h head 删除光标前一个字符 Ctrl + w Word 删除光标至单词首部 Ctrl + u 删除光标至行首 Ctrl + k 删除光标至行尾 替换类 快捷键 含义 用途 Alt + c Capital 光标单词首字符大写 Alt + u Upper 单词整体大写 Alt + l Lower 单词整体小写 复制类 快捷键 含义 用途 Ctrl + y 将内容粘贴至光标 搜索命令类 快捷键 含义 用途 Ctrl + r Retrieve 从历史记录中检索 Ctrl + g Go back 从历史记录查询中返回 Ctrl + p previous 显示出历史记录中的上一条命令 Ctrl + n next 显示出历史记录中的中的下一条 Alt + . 显示出历史记录中上一条命令的参数 控制命令 快捷键 含义 用途 Ctrl + l 清屏 Ctrl + o Operator 执行当前命令，并选择上一条命令 Ctrl + s Stop 停止屏输出 Ctrl + q Quit 退出输出模式 Ctrl + c 终止命令 Ctrl + z 挂起命令到后台并暂停 交换命令 快捷键 含义 用途 Ctrl + t Transform 与交换光标前字符交换 Alt + t Transform 交换与光标单词交换 Bang命令 快捷键 含义 用途 !! 执行上一条命令 !N 重新执行第N条命令,比如 !3 !-N 重新执行倒数第N条命令 !-3 !(word segement) 执行最近以单词为首部的命令 !$ 替代上一命令的最后一参数并执行 !* 替代上一命令的所有参数并执行 !!(Word) 在上一条命令的后面追加 string ，并执行。 !N(Word) 在第N条指令后面追加string，并执行。 (order):p 上述所有执行命令后:p代表回显命令而不是执行 ^(origin word)^(update word) 替换上一命令中第一个出现的单词并执行 bash快捷键与vim快捷键易混淆点bash命令行快捷键与vim快捷键的几个易混淆的区别 w区别bash ctrl + w是向左删除一个单词vim d + w 是向后删除至单词尾部 单词移动区别bash Alt + f, Alt + b 代表forward和backward向右向左分别移动一个单词linux b e 代表 Begin End 分别移动到单词的首部和尾部ctrl + f ,ctrl + b 代表forward和backward向前向后翻页]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>